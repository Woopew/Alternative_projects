#include "queue.h"#include <stdlib.h>#include <stdio.h>/* Implementera interface från queue.h här *///*Skapar en ny (tom) köQueuePtr new_queue(){						    QueuePtr q;    q = (struct QueueElement*)calloc(1,sizeof(struct QueueElement));     //Allokera plats för strukt    q->prio = MAX_PRIO;              q->data = NULL;    q->next = NULL;    return q;}//*Tar bort kön helt och hålletvoid delete_queue(QueuePtr q){                  clear(q);    free(q);            //Tar bort hela structen}//*Tar bort köelementen men behåller könvoid clear(QueuePtr q) {        while (q->next != NULL) {               //Sålänge q-next inte är NULL finns det celler i kön som ska tas bort    while (q->next != NULL) {               //Sålänge q-next inte är NULL finns det celler i kön som ska tas bort        remove_first (q);    }}                 	//*Räknar köns aktuella längdint  size(QueuePtr q) {    int c = 0;                                  //Räknare        while(q->next != NULL){                     //Räknar kölängd        c++;        q = q->next;    }        return c;                                   //Returnerar kölängd}//*Lägger in d på rätt plats void add(QueuePtr q, int prio, DataPtr d){    QueuePtr node;    node = (struct QueueElement*)calloc(1,sizeof(struct QueueElement));     //skapar nytt element        int a = size(q);        //kontroll    node->prio = prio;          //lägger in data och prio    node->data = d;    while (q->prio >= prio) {        if (q->next == NULL){   //om första elementet inte finns, lägg nya där.            q->next = node;            return;        }    else if ((q->prio == prio && q->next->prio != prio) || (q->next->prio < prio)) {        //om nästa prio är samma som prio och nästa elements prio inte är prio        node->next = q->next;                                                              //eller om nästa elements prio är mindre än prio        q->next = node;                                                                    //så lägger vi in elementet på platsen        return;    }    q = q->next;               //kollar nästa element om inget villkor uppfyllt    }    }//*Avläser första dataelementet DataPtr get_first(QueuePtr q){    QueuePtr tempo_q;    if(q->next == NULL)             //om ingen cell finns i kö returneras data i köhållaren    return q->data;    tempo_q = q->next;    return tempo_q->data;           //annars returneras data från elemnt i kö    }//*Tar bort första köelementetvoid remove_first(QueuePtr q){    QueuePtr temp_q;            //skapar temporär structpekare        if(q->next == NULL)         //Om första elementet är noll finns inget att radera -> return        return;        temp_q = q->next;        //temporär struct tilldelas element 1        q->next = temp_q->next;     //skriver in element 2 på element 1-plats    free(temp_q);               //frigör minnet i borttagna struct        }